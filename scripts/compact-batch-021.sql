-- Compact batch 21/29: rows 1001-1050

INSERT INTO task_inspiration (category, subcategory, subsubcategory, description, difficulty, tags) VALUES
('Security & Cryptography', 'Authentication & Access Control', 'Session Management & Revocation', 'Configure an OpenSSH service to support key-based session revocation by adding a revoke-key command that, given a public key or fingerprint, updates the RevokedKeys file, reloads sshd, enumerates and terminates any active sessions established with that key, and emits a machine-readable report. Verify that future logins with the revoked key are refused while unaffected users remain connected.', NULL, NULL),
('Security & Cryptography', 'Authentication & Access Control', 'Session Management & Revocation', 'Extend a JWT-based FastAPI authentication service to implement session-level revocation using per-token jti entries in Redis with TTL and refresh-token rotation with reuse detection that triggers immediate user-wide logout. Provide a CLI/endpoint to revoke all sessions for a username and verify that revoked access tokens return 401 while new logins succeed, with revocation instantly propagated via Redis pub/sub.', NULL, ARRAY['redis']),
('Security & Cryptography', 'Authentication & Access Control', 'Session Management & Revocation', 'Implement cluster-wide session revocation for a demo API by adding a PostgreSQL-backed denylist keyed by JWT jti with expiration matching token exp, and wiring LISTEN/NOTIFY to invalidate in-process caches immediately. Provide a CLI revoker that accepts a token or jti and proves the revoked session is rejected instantly across processes while other active sessions remain valid.', NULL, ARRAY['api', 'postgresql']),
('Security & Cryptography', 'Authentication & Access Control', 'Session Management & Revocation', 'Implement refresh-token rotation with reuse detection and a centralized, Redis-backed revocation list for a JWT-based API, propagating revocations to all workers via pub/sub. Verify that using a stolen refresh token revokes its entire chain and that rotating the JWKS signing key invalidates only old-key tokens while unaffected sessions continue.', NULL, ARRAY['redis', 'api']),
('Security & Cryptography', 'Cryptographic Operations', 'Digital Signatures & Verification', 'Create a CLI that canonicalizes JSON per RFC 8785 (JCS) and generates/verifies detached Ed25519 signatures over the canonical bytes using local PEM keypair files. Verification must accept semantically identical JSON regardless of whitespace or key order and exit non-zero if any value changes.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Digital Signatures & Verification', 'Create a CLI that canonicalizes a directory into a Merkle root (including path, mode, size, and SHA-256 for every file) and produces a detached Ed25519 signature for that root. Implement a verify subcommand that, given the public key and signature, detects any tampering and prints a deterministic list of mismatched paths or ''VERIFIED'' on success.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Digital Signatures & Verification', 'Create a terminal CLI that signs artifacts with Ed25519 producing detached .sig files and verifies downloads against a local trust store using a configurable threshold policy (e.g., require 2-of-3 maintainer signatures). Output a JSON report detailing key IDs verified, failures, and overall status, and support key rotation by marking old keys as retired while still validating past releases.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Digital Signatures & Verification', 'Implement a CLI tool that verifies OpenPGP cleartext-signed messages (RFC 4880) with correct canonical text handling (CRLF normalization, dash-escaping, and trailing whitespace) against a provided public keyring. The tool scans /app/messages for .asc files and outputs a per-file validity report to /app/verification.json.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Digital Signatures & Verification', 'Recover a secp256k1 ECDSA private key from two signatures that reused the same nonce k using the provided message digests and (r,s) pairs in /app/signatures.log, and output the key in hex to /app/privkey.hex. Use the recovered key to produce a DER-encoded detached signature for /app/release.bin at /app/release.bin.sig, and include a verify.py that prints VERIFIED when the signature checks against the derived public key.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Encryption & Decryption', 'Build a CLI that performs envelope encryption of a directory using a hybrid RSA-OAEP (recipient key) + AES-256-GCM (data) scheme in a streaming fashion (tar -> encrypt) to produce a single archive.enc with a minimal JSON header. Provide a decrypt command that uses the recipient’s RSA private key to recover the data key, verify integrity, and reconstruct the directory byte-for-byte, failing on any tag or SHA-256 manifest mismatch.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Encryption & Decryption', 'Create a CLI that performs hybrid envelope encryption for a directory: each file is encrypted with a fresh AES-256-GCM key and nonce, and the key is wrapped for multiple recipients using RSA-OAEP (SHA-256), emitting a per-file JSON manifest with wrapped keys, nonce, and tag. Implement a decrypt mode that accepts any matching recipient private key, verifies tags before writing, reconstructs paths and permissions, and aborts on any authentication failure.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Encryption & Decryption', 'Implement a hybrid envelope-encryption CLI that recursively encrypts a directory using per-file random AES-256-GCM keys, wrapping each key with an RSA-2048 public key and preserving permissions/mtimes via a JSON manifest. Provide a decrypt/verify command that uses the RSA private key to restore files byte-for-byte and detect tampering via AEAD tag checks and SHA-256 hashes.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Encryption & Decryption', 'Implement an envelope decryption tool that processes all *.enc files under /app/data: each file begins with a base64 JSON header containing an RSA-OAEP-wrapped AES-256-GCM key and 12-byte nonce, followed by raw ciphertext and tag. Use the PEM private key at /app/keys/priv.pem to unwrap keys, decrypt outputs to /app/dec preserving directory structure, and write a decrypt.log listing any files that fail authentication.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Encryption & Decryption', 'Use OpenSSL CMS to implement multi-recipient envelope encryption of a file with AES-256-GCM using both an RSA and an EC certificate, then demonstrate that either private key can decrypt while tampering triggers authentication failure. Automate key/cert generation, encryption, per-recipient decryption, and produce the recovered plaintext and an audit log of verification steps.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Hashing & Integrity Verification', 'Build a CLI that creates a chunked SHA-256 Merkle-tree manifest for a directory (e.g., 4 KiB chunks), emitting a root hash and inclusion proofs, and a verifier that can validate a specific file or chunk without re-hashing the entire dataset. The verifier must pinpoint tampered chunks and output a minimal diff (paths and chunk indexes) with expected vs actual hashes.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Hashing & Integrity Verification', 'Build a command-line verifier that, given a directory of fixed-size file chunks and their inclusion proofs plus a claimed root hash, validates a Merkle tree over the chunks (SHA-256 by default) and identifies any tampered chunks. Write the zero-based indices of all failing chunks to /app/bad_chunks.txt and exit non-zero if the computed root does not match.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Hashing & Integrity Verification', 'Implement a CLI that computes a deterministic Merkle tree over /app/data (leaf = SHA-256 of file contents with executable-bit encoded; internal = SHA-256(left||right) in stable lexicographic path order) and verifies the root against /app/expected_root.txt. Output /app/verification_report.json listing any files or links violating integrity (hashing symlink targets, handling Unicode and hardlinks, skipping sockets/FIFOs).', 'hard', NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Hashing & Integrity Verification', 'Implement a CLI that generates a SHA-256 Merkle tree manifest for a directory (capturing file sizes, permissions, and symlink targets) and outputs the root hash to a JSON file. Provide a verify mode that loads the manifest to report added/removed files, metadata changes, and chunk-level byte-range differences for large files, honoring ignore patterns in a .integrityignore.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Hashing & Integrity Verification', 'Implement a CLI tool that computes a deterministic SHA-256 Merkle tree over all regular files in /app/data (sorted paths), outputs the root to /app/output/root.txt, and can emit and verify inclusion proofs for any file. Use it to validate a provided set of proofs and write the paths of any tampered files to /app/output/tampered.txt.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Key Generation & Management', 'Create an offline GPG primary certification key and add dedicated signing, encryption, and authentication subkeys; export a revocation certificate and relocate the primary key to an “offline” store. Implement a rotation that replaces the encryption subkey, updates the public keyring, and proves functionality by signing, encrypting, and decrypting test data using only the subkeys.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Key Generation & Management', 'Design a JWKS-based JWT signing key rotation workflow: generate an initial Ed25519 signing key and JWKS, issue a token with a kid, then rotate by adding a new key, switching issuance, and finally retiring the old key. Provide commands/scripts to validate both old and new tokens during the overlap window and only the new token after finalization, writing verification outcomes to an output file.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Key Generation & Management', 'Establish an internal SSH Certificate Authority that issues, revokes, and rotates user and host certificates via shell scripts. Validate by configuring sshd to trust the CA, publishing a KRL, rotating to a new CA key with dual-trust during migration, and demonstrating that only valid, non-revoked certificates can authenticate.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Key Generation & Management', 'Set up an SSH Certificate Authority that issues both user and host certificates, configure a local sshd to trust the CA, and prove access requires a signed user cert and a valid host cert signature. Rotate the CA by generating a new key, re-signing credentials, publishing a Key Revocation List for the old CA/host certs, and demonstrate that old certs are refused while new ones succeed.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Randomness & Entropy Generation', 'Build a user-space entropy combiner and CTR-DRBG that gathers timing jitter and kernel getrandom(), applies SP 800-90B on-line health tests to raw samples, and derives output via HKDF + AES-CTR. Provide a CLI that emits N bytes, supports reseed, blocks until a configurable entropy threshold is met, and refuses to reuse state across fork unless reseeded.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Randomness & Entropy Generation', 'Implement a CLI entropy-mixer that collects bits from getrandom(), optional RDRAND, and CPU timing jitter, combines them via HKDF-SHA256 into a seed, and drives a ChaCha20-DRBG with fork detection and periodic reseeding to emit N bytes. Provide a health subcommand that performs basic randomness sanity checks and refuses to run if only a single untrusted source is present.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Randomness & Entropy Generation', 'Implement a ChaCha20-based DRBG CLI seeded exclusively via Linux getrandom, with a timing-jitter collector for periodic reseeding and online health tests (FIPS continuous test and SP 800-90B repetition/adaptive proportion). Generate 512 KiB of random data to /app/out.bin and a JSON health report with reseed events and PASS/FAIL to /app/health.json.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Randomness & Entropy Generation', 'Implement a user-space ChaCha20-DRBG that seeds from getrandom(2), a persistent seed file, and timer jitter mixed via HKDF-SHA256, and atomically commits reseed state. Provide a CLI that emits N random bytes and a JSON health report (sources, reseed_count), and passes a compromise-and-recover test for forward/backward secrecy.', NULL, NULL),
('Security & Cryptography', 'Cryptographic Operations', 'Randomness & Entropy Generation', 'Implement a user-space entropy collector that samples CPU timing jitter and other non-blocking sources, conditions them with SHA-256, and seeds a ChaCha20-based CSPRNG with a CLI to emit N bytes to /app/output/random.bin. Include basic health tests (repetition count and adaptive proportion) and persistent reseed state to avoid output reuse across restarts.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'File & Memory Forensics', 'Analyze a Linux RAM dump to locate a shared object mapped from a deleted path or memfd that indicates code injection. Carve the ELF from the dump, save it to /app/output/evil.so with its SHA-256, and report the hosting PID and the suspicious VMAs involved.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'File & Memory Forensics', 'Analyze a Linux memory image to locate a ChaCha20-Poly1305 key and nonce left in a suspected process’s heap, reconstruct them from little-endian 32-bit words, and decrypt /app/capture.enc into /app/plaintext.out. Record the PID and virtual address where the key was recovered in /app/findings.txt.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'File & Memory Forensics', 'Analyze a Linux process memory dump to recover an in-memory OpenPGP private key (ASCII-armored or binary), reconstruct and import the key, and decrypt a provided ciphertext to validate the extraction.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'File & Memory Forensics', 'Given a Linux process core dump and an AES-CTR–encrypted blob, recover the 32-byte AES key from memory artifacts (e.g., key schedule structures or contiguous hex bytes) and use it to decrypt the blob to plaintext. Validate success by matching the plaintext’s checksum against a provided reference.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'File & Memory Forensics', 'Given a Linux process core dump produced during an active ransomware run, carve the ChaCha20-Poly1305 master key and per-file nonces from memory and use them to decrypt all samples under /app/encrypted to /app/recovered. Output a machine-readable incident report including the recovered key material, originating PID/command line, and hashes of the decrypted files.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Log Analysis & Intrusion Detection', 'Analyze BIND9 query logs and system auth logs to detect DNS tunneling via long high-entropy subdomains and elevated NXDOMAIN rates, then identify the tunneling domain, originating client IP, and time window. Write findings to /app/output/report.json and provide a CLI that prints the top 5 suspicious FQDNs with counts based on your heuristics.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Log Analysis & Intrusion Detection', 'Analyze Suricata EVE JSON and SSH auth logs to detect a DNS TXT-based tunneling session followed by lateral movement via successful SSH login from the same source IP. Output the exfiltration domain and compromised username to /app/findings.json.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Log Analysis & Intrusion Detection', 'Correlate nginx access.log, /var/log/auth.log, /var/log/cron.log, and syslog to detect a webshell-driven intrusion: identify the initial exploit request and source IP, enumerate compromised accounts via SSH, and reconstruct the timeline through persistence installation and data exfiltration. Write the attacker IP(s), first compromise timestamp, compromised usernames, path and SHA256 of the dropped payload, and the exfil destination to /app/incident_report.txt.', NULL, ARRAY['installation']),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Log Analysis & Intrusion Detection', 'Implement a terminal tool that ingests DNS resolver logs and network flow summaries to detect DNS tunneling exfiltration via heuristics (label entropy, query length uniformity, periodicity) and correlate suspicious domains to source hosts. Output a ranked alert list, a chronological incident timeline, and a JSON file of IOCs (domains, client IPs, first/last seen, estimated bytes).', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Log Analysis & Intrusion Detection', 'Parse DNS resolver logs (e.g., BIND/Unbound) to detect DNS tunneling by flagging high-entropy, long subdomains with abnormal query/NXDOMAIN rates. Attribute offending client IPs and reconstruct the exfiltrated payload by decoding base32/base64 subdomain chunks into /app/exfiltrated.txt.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Malware Behavior Analysis', 'Create a terminal-based workflow that unpacks a multi-stage Linux dropper (bash + ELF), statically recovers its C2 configuration by deobfuscating an XOR+Base64 blob, and dynamically confirms behavior by tracing syscalls and outbound DNS/HTTP. Output a JSON report listing decrypted C2 domain(s), beacon interval, persistence mechanisms (e.g., ld.so.preload or cron edits), files touched, and any exfiltration paths.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Malware Behavior Analysis', 'Inspect an obfuscated Linux ELF dropper that persists via /etc/ld.so.preload and exfiltrates data using DNS TXT queries. Recover and decode its embedded C2 domain (XOR+base64) to /app/iocs.txt and cleanly remove the persistence without breaking legitimate binaries.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Malware Behavior Analysis', 'Perform hybrid (static and controlled dynamic) analysis of a suspicious Linux ELF dropper that conceals its configuration via XOR+Base64 and establishes persistence via a systemd user service, using tools like objdump, strings, strace, and a local network namespace to observe behavior safely. Recover and save the decrypted config, enumerate all IOCs (C2 endpoints, file paths, service names), and produce a concise YARA rule that identifies the sample while minimizing false positives.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Malware Behavior Analysis', 'Perform static and controlled dynamic analysis of a packed Go-based Linux ELF dropper that decrypts its configuration at runtime. Without contacting external hosts, recover and write its decoded C2 endpoints, mutex/campaign ID, and installed persistence artifacts (e.g., systemd unit/timer names or crontab entries) to /app/iocs.txt, and extract the embedded payload to /app/payload.bin.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Malware Behavior Analysis', 'Statically and/or dynamically analyze an obfuscated Linux ELF dropper at /app/samples/dropper to recover its behavior and configuration, including persistence mechanism and C2 endpoints. Decrypt the embedded config (XOR key stored in the .note.sec_key section) and write the persistence artifact path, targeted exfiltration globs, and C2 domain:port as JSON to /app/iocs.json.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Timeline Reconstruction', 'Correlate Apache/Nginx access logs, SSH auth logs, Zeek HTTP/conn logs, and a small pcap with mixed time zones to reconstruct the compromise timeline from first exploit to data exfiltration. Output a UTC-normalized CSV of events and a brief report identifying attacker IPs, exploited endpoint, privilege escalation, persistence, and exfiltration channel.', NULL, NULL),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Timeline Reconstruction', 'Correlate Linux auth logs, web server access logs, Docker daemon/container JSON logs, and shell history with partial clock skew to reconstruct a unified UTC timeline of a short-lived breach from initial credential reuse through containerized payload execution to data exfiltration and a log-tampering attempt. Produce a machine-readable CSV including timestamp, event label, actor/IP, and source file, noting any time-skew adjustments applied.', NULL, ARRAY['web', 'docker', 'container']),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Timeline Reconstruction', 'Create a CLI that parses rotated nginx access logs, SSH/auth logs, and Linux auditd logs from multiple hosts, auto-normalizes timestamps (timezones, DST changes, and a known 7-minute skew), and reconstructs a single UTC incident timeline from initial web hit to privilege escalation. Output a CSV with sequence numbers, unified timestamps, actor (IP/user), correlated PIDs, and flags for suspected timestomping when file MAC times conflict with process execution events.', NULL, ARRAY['web']),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Timeline Reconstruction', 'From /app/artifacts (kube-apiserver audit logs, containerd logs, application auth logs, and a crontab snapshot), reconstruct a minute-by-minute timeline of a Kubernetes pod compromise that began with a leaked CI/CD token, escalated via an over-privileged service account, established cron-based persistence, and exfiltrated data to an external host. Output a strictly chronological /app/output/timeline.json with fields [timestamp, source, action, subject, details] and tag the events of initial access, privilege escalation, persistence, and exfiltration.', NULL, ARRAY['kubernetes']),
('Security & Cryptography', 'Forensics & Incident Analysis', 'Timeline Reconstruction', 'Reconstruct a minute-by-minute timeline of a supply-chain compromise by correlating auditd, apt/dpkg logs, pip metadata, systemd journal, and netflow/pcap artifacts from initial package install to persistence and exfiltration. Output a sorted timeline.csv and a findings.txt naming the malicious package, the first persistence write path, and the exfiltration destination IP.', NULL, NULL),
('Security & Cryptography', 'Network & System Penetration Testing', 'Exploit Simulation & Payload Delivery', 'Against a sandboxed Flask web app, identify a server-side template injection sink in a preview endpoint and craft an obfuscated Jinja2 payload that writes /tmp/mark_ssti.txt and exfiltrates http://127.0.0.1:8081/flag to /app/result.txt despite a naive WAF blocking common tokens. Success is validated by the presence of the marker file and the exact flag content.', NULL, ARRAY['web']),
('Security & Cryptography', 'Network & System Penetration Testing', 'Exploit Simulation & Payload Delivery', 'Assess a misconfigured Docker Engine API exposed on localhost by deploying a minimal containerized payload that mounts the host filesystem read-only to retrieve a designated secret. Copy the secret to /app and then cleanly remove all created containers, images, and networks to restore the environment.', NULL, ARRAY['docker', 'api']);
